<!DOCTYPE html>
<html lang="en" class="dark">
<head>
<meta charset="UTF-8">
<title>HackoAI â€¢ Tailwind Edition ğŸ¨</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"></script>

<style>
@import url('https://fonts.googleapis.com/css2?family=Smooch+Sans:wght@100..900&display=swap');

* {
  font-family: 'Smooch Sans', sans-serif;
}

@keyframes fadeIn {
  to { opacity: 1; }
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.6; }
}

.msg {
  animation: fadeIn 0.25s forwards;
  opacity: 0;
}

.spinner {
  width: 18px;
  height: 18px;
  border: 3px solid #e5e7eb;
  border-top: 3px solid #2563eb;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

pre code {
  font-size: 13px;
}

.katex-display {
  max-width: 100%;
  overflow-x: auto;
  overflow-y: hidden;
  padding-bottom: 4px;
}
</style>

<script>
tailwind.config = {
  darkMode: 'class',
  theme: {
    extend: {
      fontFamily: {
        sans: ['Smooch Sans', 'sans-serif']
      }
    }
  }
}
</script>
</head>

<body class="bg-gradient-to-br from-slate-950 via-blue-950 to-slate-900 text-slate-100 h-screen flex items-center justify-center overflow-hidden">

<div class="w-full max-w-7xl h-[90vh] flex gap-0 shadow-2xl rounded-2xl overflow-hidden backdrop-blur-xl bg-slate-900/50 border border-slate-700/50">
  
  <!-- SIDEBAR -->
  <div id="sidebar" class="w-64 bg-gradient-to-b from-slate-900/90 to-slate-950/95 border-r border-slate-700 flex flex-col transition-transform duration-300 md:relative fixed top-0 left-0 h-full z-50 shadow-2xl">
    
    <button id="menuCloseBtn" class="hidden md:hidden absolute top-3 right-3 bg-blue-600 text-white px-3 py-1.5 rounded-lg text-sm font-semibold hover:bg-blue-700 transition-colors">âœ•</button>
    
    <div class="p-4 border-b border-slate-700 space-y-3">
      <input type="text" id="searchBox" placeholder="ğŸ” Search chats..." class="w-full px-3 py-2 bg-slate-800 border border-slate-600 rounded-lg text-sm text-slate-100 placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all">
      
      <div class="flex gap-2">
        <button onclick="newChat()" class="flex-1 bg-blue-600 text-white px-3 py-1.5 rounded-lg text-xs font-semibold hover:bg-blue-700 transition-all hover:shadow-lg hover:shadow-blue-500/50">+ New</button>
        <button onclick="exportAll()" class="flex-1 bg-emerald-600 text-white px-3 py-1.5 rounded-lg text-xs font-semibold hover:bg-emerald-700 transition-all">ğŸ“¥</button>
        <button onclick="importAll()" class="flex-1 bg-emerald-600 text-white px-3 py-1.5 rounded-lg text-xs font-semibold hover:bg-emerald-700 transition-all">ğŸ“¤</button>
      </div>
    </div>

    <div id="historyList" class="flex-1 overflow-y-auto p-2 space-y-1 scrollbar-thin scrollbar-thumb-blue-600 scrollbar-track-slate-800"></div>
  </div>

  <!-- MAIN APP -->
  <div class="flex-1 flex flex-col bg-slate-900/80 backdrop-blur-md">
    
    <!-- HEADER -->
    <header class="px-4 py-3 border-b border-slate-700 flex justify-between items-center bg-gradient-to-r from-slate-900/90 to-slate-800/90 backdrop-blur-lg">
      <div class="flex items-center gap-3">
        <button id="menuBtn" class="md:hidden bg-slate-700 text-white px-2 py-1 rounded-lg hover:bg-slate-600 transition-colors">â˜°</button>
        <span id="headerTitle" class="font-bold text-lg text-blue-400 cursor-pointer hover:text-blue-300 transition-colors">HackoAI</span>
      </div>

      <div class="flex gap-2 items-center flex-wrap">
        <button onclick="exportChat()" class="bg-slate-700 text-white px-3 py-1.5 rounded-lg text-sm hover:bg-slate-600 transition-all hover:shadow-lg">ğŸ’¾</button>
        <button onclick="copyAll()" class="bg-slate-700 text-white px-3 py-1.5 rounded-lg text-sm hover:bg-slate-600 transition-all hover:shadow-lg">ğŸ“‹</button>
        <button onclick="clearChat()" class="bg-slate-700 text-white px-3 py-1.5 rounded-lg text-sm hover:bg-red-600 hover:border-red-500 transition-all hover:shadow-lg">ğŸ—‘ï¸</button>
        <button id="ttsToggle" onclick="toggleTTS()" class="bg-purple-600 text-white px-3 py-1.5 rounded-lg text-sm hover:bg-purple-700 transition-all hover:shadow-lg hover:shadow-purple-500/50">ğŸ”Š</button>
        
        <select id="imageModel" class="bg-slate-700 text-white px-3 py-1.5 rounded-lg text-xs border border-slate-600 focus:outline-none focus:ring-2 focus:ring-blue-500 max-w-[140px] truncate">
          <option value="stabilityai/stable-diffusion-xl-base-1.0">SDXL Base</option>
          <option value="black-forest-labs/FLUX.1-dev">FLUX Dev</option>
          <option value="stabilityai/stable-diffusion-3.5-large">SD 3.5 Large</option>
        </select>

        <select id="textModel" class="bg-slate-700 text-white px-3 py-1.5 rounded-lg text-xs border border-slate-600 focus:outline-none focus:ring-2 focus:ring-blue-500 max-w-[140px] truncate">
          <option value="deepseek/deepseek-r1-0528:free">DeepSeek R1</option>
          <option value="meta-llama/llama-3.3-70b-instruct:free">LLaMA 3.3 70B</option>
          <option value="google/gemini-2.0-flash-exp:free">Gemini 2.0 Flash</option>
        </select>
      </div>
    </header>

    <!-- CHAT AREA -->
    <div id="chat" class="flex-1 overflow-y-auto p-4 space-y-4 bg-gradient-to-b from-slate-900/60 to-slate-950/80 scrollbar-thin scrollbar-thumb-blue-600 scrollbar-track-slate-800"></div>

    <button id="scrollBottom" onclick="scrollToBottom()" class="hidden fixed bottom-24 right-8 bg-blue-600 text-white px-4 py-3 rounded-full shadow-2xl hover:bg-blue-700 transition-all hover:shadow-blue-500/50">â†“</button>

    <!-- FOOTER -->
    <footer class="flex gap-2 p-3 border-t border-slate-700 bg-gradient-to-r from-slate-900/90 to-slate-800/90 backdrop-blur-lg">
      <button id="voiceBtn" onclick="toggleVoiceInput()" class="bg-emerald-600 text-white px-4 py-2 rounded-lg font-semibold hover:bg-emerald-700 transition-all hover:shadow-lg hover:shadow-emerald-500/50">ğŸ¤</button>
      
      <div class="flex-1 flex flex-col">
        <input id="input" placeholder="Type or speak... (Ctrl+B for new chat)" class="w-full px-4 py-2 bg-slate-800 border border-slate-600 rounded-lg text-slate-100 placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all">
        <div id="charCounter" class="text-xs text-slate-500 text-right px-2 py-1">0 chars</div>
      </div>

      <button onclick="send()" class="bg-blue-600 text-white px-6 py-2 rounded-lg font-bold hover:bg-blue-700 transition-all hover:shadow-lg hover:shadow-blue-500/50">Send</button>
    </footer>
  </div>
</div>

<input type="file" id="importFile" accept=".json" class="hidden">

<script>
// ===== GLOBALS =====
const chat = document.getElementById("chat");
const input = document.getElementById("input");
const sidebar = document.getElementById("sidebar");
const historyList = document.getElementById("historyList");
const searchBox = document.getElementById("searchBox");
const scrollBottom = document.getElementById("scrollBottom");
const charCounter = document.getElementById("charCounter");
const headerTitle = document.getElementById("headerTitle");
const menuBtn = document.getElementById("menuBtn");
const menuCloseBtn = document.getElementById("menuCloseBtn");

let sessions = JSON.parse(localStorage.getItem("hackoai_sessions") || "{}");
let currentId = localStorage.getItem("hackoai_current") || null;
let lastUserPrompt = null;
let isGenerating = false;
let recognition = null;
let ttsEnabled = localStorage.getItem('hackoai_tts') === 'true';
let currentUtterance = null;

// ===== INIT =====
function initApp() {
  if (Object.keys(sessions).length === 0 || !sessions[currentId]) {
    createNewChat();
  }
  renderHistory();
  updateHeaderTitle();
  loadChatMessages();
  initVoice();
  initEventListeners();
}

function createNewChat() {
  currentId = Date.now().toString();
  sessions[currentId] = {
    id: currentId,
    title: "New Chat",
    messages: [],
    timestamp: Date.now(),
    pinned: false,
    autoTitled: false
  };
  saveSessions();
}

function getCurrentSession() {
  return sessions[currentId] || Object.values(sessions)[0] || null;
}

function saveSessions() {
  localStorage.setItem("hackoai_sessions", JSON.stringify(sessions));
  localStorage.setItem("hackoai_current", currentId);
  renderHistory();
  updateHeaderTitle();
}

function saveMessage(role, content) {
  const session = getCurrentSession();
  session.messages.push({ role, content });
  session.timestamp = Date.now();
  saveSessions();
}

// ===== VOICE =====
function initVoice() {
  if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    recognition = new SpeechRecognition();
    recognition.continuous = false;
    recognition.interimResults = false;
    recognition.lang = 'en-US';

    recognition.onresult = (event) => {
      const transcript = event.results[0][0].transcript;
      input.value = transcript;
      charCounter.textContent = `${transcript.length} chars`;
      document.getElementById('voiceBtn').textContent = 'ğŸ¤';
      document.getElementById('voiceBtn').classList.remove('animate-pulse', 'bg-red-600');
      document.getElementById('voiceBtn').classList.add('bg-emerald-600');
    };

    recognition.onerror = () => {
      const btn = document.getElementById('voiceBtn');
      btn.textContent = 'ğŸ¤';
      btn.classList.remove('animate-pulse', 'bg-red-600');
      btn.classList.add('bg-emerald-600');
    };

    recognition.onend = () => {
      const btn = document.getElementById('voiceBtn');
      btn.textContent = 'ğŸ¤';
      btn.classList.remove('animate-pulse', 'bg-red-600');
      btn.classList.add('bg-emerald-600');
    };
  }

  const btn = document.getElementById('ttsToggle');
  btn.textContent = ttsEnabled ? 'ğŸ”Š' : 'ğŸ”‡';
  btn.classList.toggle('bg-emerald-600', ttsEnabled);
  btn.classList.toggle('bg-purple-600', !ttsEnabled);
}

function toggleVoiceInput() {
  if (!recognition) return alert('Speech recognition not supported ğŸ˜¢');

  const btn = document.getElementById('voiceBtn');
  
  if (btn.textContent === 'âºï¸') {
    recognition.stop();
  } else {
    btn.textContent = 'âºï¸';
    btn.classList.add('animate-pulse', 'bg-red-600');
    btn.classList.remove('bg-emerald-600');
    recognition.start();
  }
}

function toggleTTS() {
  ttsEnabled = !ttsEnabled;
  localStorage.setItem('hackoai_tts', ttsEnabled);
  const btn = document.getElementById('ttsToggle');
  btn.textContent = ttsEnabled ? 'ğŸ”Š' : 'ğŸ”‡';
  btn.classList.toggle('bg-emerald-600', ttsEnabled);
  btn.classList.toggle('bg-purple-600', !ttsEnabled);
  
  if (!ttsEnabled && currentUtterance) {
    window.speechSynthesis.cancel();
  }
}

function speakText(text) {
  if (!ttsEnabled || !('speechSynthesis' in window)) return;
  
  window.speechSynthesis.cancel();
  
  const cleanText = text
    .replace(/\*\*/g, '')
    .replace(/```[\s\S]*?```/g, '[code block]')
    .replace(/`[^`]+`/g, '')
    .replace(/#{1,6}\s/g, '')
    .trim();

  if (!cleanText) return;
  
  const finalText = cleanText.length > 500 
    ? cleanText.slice(0, 500) + '... response truncated for audio'
    : cleanText;

  currentUtterance = new SpeechSynthesisUtterance(finalText);
  currentUtterance.rate = 1.1;
  currentUtterance.pitch = 1;
  currentUtterance.volume = 0.9;

  window.speechSynthesis.speak(currentUtterance);
}

// ===== RENDER HISTORY =====
function renderHistory() {
  const query = searchBox.value.toLowerCase().trim();
  let filtered = Object.values(sessions);
  
  if (query) {
    filtered = filtered.filter(s =>
      s.title.toLowerCase().includes(query)
    );
  }
  
  const sorted = filtered.sort((a, b) => b.timestamp - a.timestamp);
  
  historyList.innerHTML = "";
  
  sorted.forEach(s => {
    const div = document.createElement("div");
    div.className = `px-3 py-2 rounded-lg cursor-pointer transition-all flex justify-between items-center group ${
      s.id === currentId 
        ? 'bg-gradient-to-r from-blue-600 to-blue-700 text-white shadow-lg shadow-blue-500/50' 
        : 'bg-slate-800/50 hover:bg-slate-700/70 text-slate-300 hover:translate-x-1'
    }`;
    
    div.innerHTML = `
      <span class="text-sm truncate flex-1">${s.title}</span>
      <div class="flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
        <button onclick="togglePin('${s.id}')" class="text-xs px-1.5">${s.pinned ? 'â­' : 'â˜†'}</button>
        <button onclick="deleteChatHandler('${s.id}')" class="text-xs px-1.5 hover:text-red-400">âœ•</button>
      </div>
    `;
    
    div.onclick = () => loadChatHandler(s.id);
    historyList.appendChild(div);
  });
}

function togglePin(id) {
  sessions[id].pinned = !sessions[id].pinned;
  saveSessions();
}

function newChat() {
  createNewChat();
  chat.innerHTML = "";
  renderHistory();
  updateHeaderTitle();
}

function loadChatHandler(id) {
  currentId = id;
  loadChatMessages();
  renderHistory();
  scrollToBottom();
  if (window.innerWidth <= 768) toggleSidebar();
}

function loadChatMessages() {
  chat.innerHTML = "";
  const session = getCurrentSession();
  if (!session) return;

  session.messages.forEach(m => render(m.role, m.content, false));
  scrollToBottom();
}

function deleteChatHandler(id) {
  if (!confirm("Delete this chat? ğŸ’€")) return;
  
  delete sessions[id];
  
  if (id === currentId) {
    const remaining = Object.keys(sessions);
    if (remaining.length > 0) {
      loadChatHandler(remaining[0]);
    } else {
      newChat();
    }
  }
  saveSessions();
}

function clearChat() {
  if (!confirm("Clear current chat? ğŸ’€")) return;
  const session = getCurrentSession();
  session.messages = [];
  session.title = "New Chat";
  session.autoTitled = false;
  saveSessions();
  chat.innerHTML = "";
  render("bot", "**Chat cleared. Fresh slate ğŸ˜âœ¨**", false);
}

function toggleSidebar() {
  sidebar.classList.toggle('-translate-x-full');
}

function updateHeaderTitle() {
  headerTitle.textContent = getCurrentSession()?.title || "HackoAI";
}

function scrollToBottom() {
  chat.scrollTo({ top: chat.scrollHeight, behavior: "smooth" });
}

function time() {
  const d = new Date();
  return d.getHours().toString().padStart(2, '0') + ":" +
         d.getMinutes().toString().padStart(2, '0');
}

// ===== RENDER MESSAGE =====
function render(role, content, saveIt = true) {
  const d = document.createElement("div");
  d.className = `msg max-w-[85%] px-4 py-3 rounded-2xl shadow-lg backdrop-blur-sm ${
    role === "user" 
      ? 'self-end bg-gradient-to-br from-blue-600 to-blue-700 text-white ml-auto shadow-blue-500/50' 
      : 'self-start bg-gradient-to-br from-slate-800 to-slate-900 text-slate-100 border border-slate-700/50'
  }`;

  if (typeof content === "object" && content.type === "image") {
    const img = document.createElement("img");
    img.src = content.src;
    img.className = "rounded-xl max-w-full mt-2";
    d.appendChild(img);
  } else {
    if (window.marked) {
      d.innerHTML = marked.parse(String(content));
    } else {
      d.textContent = String(content);
    }
    
    if (window.renderMathInElement) {
      renderMathInElement(d, {
        delimiters: [
          { left: "$$", right: "$$", display: true },
          { left: "\\(", right: "\\)", display: false }
        ]
      });
    }
  }

  const t = document.createElement("div");
  t.className = "text-xs opacity-60 mt-2";
  t.textContent = time();
  d.appendChild(t);

  chat.appendChild(d);
  chat.scrollTop = chat.scrollHeight;

  if (window.hljs) {
    setTimeout(() => {
      d.querySelectorAll("pre code").forEach(block => {
        hljs.highlightElement(block);
      });
    }, 100);
  }

  if (saveIt) saveMessage(role, content);
  return d;
}

// ===== STREAMING =====
async function streamBotInChunks(fullText, baseChunkSize = 50) {
  const d = document.createElement("div");
  d.className = "msg max-w-[85%] px-4 py-3 rounded-2xl shadow-lg backdrop-blur-sm self-start bg-gradient-to-br from-slate-800 to-slate-900 text-slate-100 border border-slate-700/50";
  chat.appendChild(d);

  let renderedText = "";
  const session = getCurrentSession();
  saveMessage("bot", "");
  const botIndex = session.messages.length - 1;

  const totalLength = fullText.length;
  let chunkSize = totalLength > 5000 ? 100 : baseChunkSize;

  for (let i = 0; i < fullText.length; i += chunkSize) {
    const chunk = fullText.slice(i, i + chunkSize);
    renderedText += chunk;
    
    if (window.marked) {
      d.innerHTML = marked.parse(renderedText);
    } else {
      d.textContent = renderedText;
    }
    
    chat.scrollTop = chat.scrollHeight;
    session.messages[botIndex].content = renderedText;
    
    if (i % (chunkSize * 5) === 0) saveSessions();

    await new Promise(r => setTimeout(r, totalLength > 5000 ? 5 : 15));
  }

  speakText(renderedText);
  
  if (window.hljs) {
    setTimeout(() => {
      d.querySelectorAll("pre code").forEach(block => {
        hljs.highlightElement(block);
      });
    }, 100);
  }

  saveSessions();
}

// ===== SEND =====
async function send() {
  if (isGenerating) return alert("Generation in progress");

  let prompt = input.value.trim();
  if (!prompt) return;

  isGenerating = true;
  lastUserPrompt = prompt;

  const session = getCurrentSession();
  const shouldAutoTitle = !session.autoTitled && session.messages.filter(m => m.role === "user").length === 0;

  input.value = "";
  charCounter.textContent = "0 chars";

  const isImage = prompt.startsWith("/img ");
  if (isImage) prompt = prompt.slice(5);

  render("user", prompt);

  const loading = document.createElement("div");
  loading.className = "msg max-w-[85%] px-4 py-3 rounded-2xl shadow-lg self-start bg-gradient-to-br from-slate-800 to-slate-900";
  loading.innerHTML = "<div class='spinner'></div>";
  chat.appendChild(loading);
  chat.scrollTop = chat.scrollHeight;

  try {
    if (isImage) {
      const model = document.getElementById("imageModel").value;
      const res = await fetch("https://hackoai-worker.tariqmtaezeem.workers.dev/hf/img", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ prompt, model })
      });

      if (!res.ok) throw new Error("Image gen failed");

      const { url } = await res.json();
      loading.remove();
      isGenerating = false;

      const img = document.createElement("img");
      img.src = url;
      img.className = "rounded-xl max-w-full";

      const div = document.createElement("div");
      div.className = "msg max-w-[85%] px-4 py-3 rounded-2xl shadow-lg self-start bg-gradient-to-br from-slate-800 to-slate-900";
      div.appendChild(img);
      chat.appendChild(div);
      
      saveMessage("bot", { type: "image", src: url });
    } else {
      const model = document.getElementById("textModel").value;
      const messages = session.messages
        .filter(m => typeof m.content === "string")
        .map(m => ({ role: m.role === "bot" ? "assistant" : "user", content: m.content }));

      messages.push({ role: "user", content: prompt });

      const res = await fetch("https://hackoai-worker.tariqmtaezeem.workers.dev/chat", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ model, messages })
      });

      const data = await res.json();
      const answer = data.choices?.[0]?.message?.content || "ğŸ’€ Empty response";
      
      loading.remove();
      await streamBotInChunks(answer);
      isGenerating = false;

      if (shouldAutoTitle) {
        session.title = prompt.slice(0, 40) + (prompt.length > 40 ? '...' : '');
        session.autoTitled = true;
        saveSessions();
      }
    }
  } catch (err) {
    console.error(err);
    isGenerating = false;
    loading.remove();
    render("bot", "**Error: " + err.message + " ğŸ’€**");
  }
}

// ===== EXPORT/IMPORT =====
function exportChat() {
  const session = getCurrentSession();
  let text = `# ${session.title}\n\n`;
  session.messages.forEach(m => {
    if (typeof m.content === "string") {
      text += `**${m.role.toUpperCase()}:**\n${m.content}\n\n`;
    }
  });
  
  const blob = new Blob([text], { type: "text/markdown" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `${session.title.replace(/[^a-z0-9]/gi, '_')}.md`;
  a.click();
}

function copyAll() {
  const session = getCurrentSession();
  let text = "";
  session.messages.forEach(m => {
    if (typeof m.content === "string") {
      text += `${m.role.toUpperCase()}: ${m.content}\n\n`;
    }
  });
  navigator.clipboard.writeText(text);
  alert("ğŸ“‹ Copied!");
}

function exportAll() {
  const data = JSON.stringify(sessions, null, 2);
  const blob = new Blob([data], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `hackoai_backup_${Date.now()}.json`;
  a.click();
}

function importAll() {
  document.getElementById("importFile").click();
}

document.getElementById("importFile").onchange = (e) => {
  const file = e.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = (ev) => {
    try {
      const imported = JSON.parse(ev.target.result);
      if (confirm("Import chats?")) {
        Object.assign(sessions, imported);
        saveSessions();
        alert("âœ… Imported!");
      }
    } catch {
      alert("âŒ Invalid file!");
    }
  };
  reader.readAsText(file);
};

// ===== EVENT LISTENERS =====
function initEventListeners() {
  input.addEventListener("input", () => {
    const len = input.value.length;
    charCounter.textContent = `${len} chars`;
    charCounter.classList.toggle('text-red-500', len > 4000);
    charCounter.classList.toggle('text-yellow-500', len > 2000 && len <= 4000);
  });

  input.addEventListener("keydown", e => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      send();
    }
  });

  searchBox.addEventListener("input", renderHistory);

  chat.addEventListener("scroll", () => {
    const atBottom = chat.scrollHeight - chat.scrollTop - chat.clientHeight < 50;
    scrollBottom.classList.toggle('hidden', atBottom);
  });

  document.addEventListener("keydown", (e) => {
    if (e.ctrlKey && e.key === "b") {
      e.preventDefault();
      newChat();
    }
  });

  menuBtn?.addEventListener('click', toggleSidebar);
  menuCloseBtn?.addEventListener('click', toggleSidebar);
}

// ===== INIT =====
initApp();
</script>

</body>
</html>
